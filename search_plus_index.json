{"./":{"url":"./","title":"Introduction","keywords":"","body":"Python Style Guide Python is the main scripting language. This style guide is a list of dos and don'ts for Python programs. Contents Python Language Rules Lint, Imports, Packages, Exceptions, Global Variables, Nested/Local/Inner Classes and Functions, List Comprehensions, Default Iterators and Operators, Generators, Lambda Functions, Conditional Expressions, Default Argument Values, Properties, True/False Evaluations, Deprecated Language Features, Lexical Scoping, Function and Method Decorators, Threading, Power Features Python Style Rules Semicolons, Line Length, Parentheses, Indentation, Blank Lines, Whitespace, Shebang Line, Comments, Classes, Strings, Files and Sockets, TODO Comments, Imports Formatting, Statements, Access Control, Naming, Main References Google Python Style Guide Type Hinting in PyCharm typing — Support for type hints PEP 484 -- Type Hints "},"python-language-rules/lint.html":{"url":"python-language-rules/lint.html","title":"Lint","keywords":"","body":"Lint Run pylint over your code. "},"python-language-rules/imports.html":{"url":"python-language-rules/imports.html","title":"Imports","keywords":"","body":"Imports Use imports for packages and modules only. "},"python-language-rules/packages.html":{"url":"python-language-rules/packages.html","title":"Packages","keywords":"","body":"Packages Import each module using the full pathname location of the module. "},"python-language-rules/exceptions.html":{"url":"python-language-rules/exceptions.html","title":"Exceptions","keywords":"","body":"Exceptions Exceptions are allowed but must be used carefully. "},"python-language-rules/global-variables.html":{"url":"python-language-rules/global-variables.html","title":"Global Variables","keywords":"","body":"Global Variables Avoid global variables. "},"python-language-rules/classes-and-functions.html":{"url":"python-language-rules/classes-and-functions.html","title":"Nested/Local/Inner Classes and Functions","keywords":"","body":"Nested/Local/Inner Classes and Functions Nested/local/inner classes and functions are fine. "},"python-language-rules/list-comprehensions.html":{"url":"python-language-rules/list-comprehensions.html","title":"List Comprehensions","keywords":"","body":"List Comprehensions Okay to use for simple cases. "},"python-language-rules/iterators-and-operators.html":{"url":"python-language-rules/iterators-and-operators.html","title":"Default Iterators and Operators","keywords":"","body":"Default Iterators and Operators Use default iterators and operators for types that support them, like lists, dictionaries, and files. "},"python-language-rules/generators.html":{"url":"python-language-rules/generators.html","title":"Generators","keywords":"","body":"Generators Use generators as needed. "},"python-language-rules/lambda-functions.html":{"url":"python-language-rules/lambda-functions.html","title":"Lambda Functions","keywords":"","body":"Lambda Functions Okay for one-liners. "},"python-language-rules/conditional-expressions.html":{"url":"python-language-rules/conditional-expressions.html","title":"Conditional Expressions","keywords":"","body":"Conditional Expressions Okay for one-liners. "},"python-language-rules/argument-values.html":{"url":"python-language-rules/argument-values.html","title":"Default Argument Values","keywords":"","body":"Default Argument Values Okay in most cases. "},"python-language-rules/properties.html":{"url":"python-language-rules/properties.html","title":"Properties","keywords":"","body":"Properties Use properties for accessing or setting data where you would normally have used simple, lightweight accessor or setter methods. "},"python-language-rules/evaluations.html":{"url":"python-language-rules/evaluations.html","title":"True/False Evaluations","keywords":"","body":"True/False Evaluations Use the \"implicit\" false if at all possible. "},"python-language-rules/deprecated-language-features.html":{"url":"python-language-rules/deprecated-language-features.html","title":"Deprecated Language Features","keywords":"","body":"Deprecated Language Features Use string methods instead of the string module where possible. Use function call syntax instead of apply. Use list comprehensions and for loops instead of filter and map when the function argument would have been an inlined lambda anyway. Use for loops instead of reduce. "},"python-language-rules/lexical-scoping.html":{"url":"python-language-rules/lexical-scoping.html","title":"Lexical Scoping","keywords":"","body":"Lexical Scoping Okay to use. "},"python-language-rules/decorators.html":{"url":"python-language-rules/decorators.html","title":"Function and Method Decorators","keywords":"","body":"Function and Method Decorators Use decorators judiciously when there is a clear advantage. "},"python-language-rules/threading.html":{"url":"python-language-rules/threading.html","title":"Threading","keywords":"","body":"Threading Do not rely on the atomicity of built-in types. "},"python-language-rules/power-features.html":{"url":"python-language-rules/power-features.html","title":"Power Features","keywords":"","body":"Power Features Avoid these features. "},"python-style-rules/semicolons.html":{"url":"python-style-rules/semicolons.html","title":"Semicolons","keywords":"","body":"Semicolons 不要使用分号作为行终结符，也不要用分号将两个或多个命令连在一起写在一行上面。 "},"python-style-rules/line-length.html":{"url":"python-style-rules/line-length.html","title":"Line Length","keywords":"","body":"Line Length 每一行的最大长度为80个字符，不要超过80，除了注释中的URLs。 不要使用反斜线进行换行。 import引用时 from Tkinter import Tk, Frame, Button, Entry, Canvas, Text from Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END # 或 from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text, LEFT, DISABLED, NORMAL, RIDGE, END) 不要： from Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \\ LEFT, DISABLED, NORMAL, RIDGE, END 函数调用时 foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if判断时 if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 长字符串声明时 x = ('This will build a very long long ' 'long long long long long long string') 注释中的URLs # See details at # https://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html "},"python-style-rules/parentheses.html":{"url":"python-style-rules/parentheses.html","title":"Parentheses","keywords":"","body":"Parentheses 谨慎的使用括号。 不要在条件判断语句（除了多行条件判断语句）使用括号 不要在return语句中使用括号 在元组周围使用括号 正确的写法 if foo: bar() while x: x = bar() if x and y: bar() if not x: bar() return foo for (x, y) in dict.items(): 不正确的写法 if (x): bar() if not(x): bar() return (foo) "},"python-style-rules/indentation.html":{"url":"python-style-rules/indentation.html","title":"Indentation","keywords":"","body":"Indentation 使用4个空格缩进代码块。 永远不要使用tab或混合使用tab和空格。但是在多行语句中使用使用垂直对齐而不是缩进。 正确的写法 # Aligned with opening delimiter foo = long_function_name(var_one, var_two, var_three, var_four) # Aligned with opening delimiter in a dictionary foo = { long_dictionary_key: value1 + value2, ... } # 4-space hanging indent; nothing on first line foo = long_function_name( var_one, var_two, var_three, var_four) # 4-space hanging indent in a dictionary foo = { long_dictionary_key: long_dictionary_value, ... } 错误的写法 # Stuff on first line forbidden foo = long_function_name(var_one, var_two, var_three, var_four) # 2-space hanging indent forbidden foo = long_function_name( var_one, var_two, var_three, var_four) # No hanging indent in a dictionary foo = { long_dictionary_key: long_dictionary_value, ... } "},"python-style-rules/blank-lines.html":{"url":"python-style-rules/blank-lines.html","title":"Blank Lines","keywords":"","body":"Blank Lines 在顶级类或函数之间使用两个空白行，而在类函数之间使用单个空白行。 在类定义和类中第一个函数定义之间不使用空白行。 在功能或方法的合适位置使用空白行（一般在一个业务逻辑完成之后）。 "},"python-style-rules/whitespace.html":{"url":"python-style-rules/whitespace.html","title":"Whitespace","keywords":"","body":"Whitespace 按照以下规范使用空格。 括号内不要有空格 spam(ham[1], {eggs: 2}, []) 逗号、分号、冒号前不要加空格，逗号、分号、冒号后面加空格，除了行尾 if x == 4: print x, y x, y = y, x 在参数列表、索引、切片的开始括号/方括号之前不要有空格 spam(1) dict['key'] = list[index] 在运算符前后添加空格 这些运算符包括：==、、>、!=、<>、、>=、in、not in、is、is not、and、or、not。 但有些时候需要你自行判断是否需要添加空格。 在赋值运算符=前后需要添加空格，但=用于指示关键字参数或默认参数时，不要添加空格 x == 1 def complex(real, imag=0.0): return magic(r=real, i=imag) 不要使用空格对齐连续行的标记，因为它们会成为维护的负担（如:、,、#、=等） foo = 1000 # comment long_name = 2 # comment that should not be aligned dictionary = { 'foo': 1, 'long_name': 2, } 不要这样做： foo = 1000 # comment long_name = 2 # comment that should not be aligned dictionary = { 'foo' : 1, 'long_name': 2, } "},"python-style-rules/shebang-line.html":{"url":"python-style-rules/shebang-line.html","title":"Shebang Line","keywords":"","body":"Shebang Line 许多.py文件都不需要以#!开头：#!/usr/bin/env python。 但是在需要直接执行的文件中还是有必要的，它能帮助内核找到对应的Python解释器。 "},"python-style-rules/comments.html":{"url":"python-style-rules/comments.html","title":"Comments","keywords":"","body":"Comments 使用正确的样式来编写注释。 Doc Strings 文档注释是Python特有的一种风格的注释。文档注释是一个字符串，它是package、module、class、function的第一条语句。 Modules 每个项目都应该有一个许可证模板，为你的项目选择合适的许可证样板（例如，Apache 2.0，BSD，LGPL，GPL）。 Functions and Methods 函数必须有文档注释，除了以下情况： 非常短 功能或业务逻辑非常简单、明显 函数的文档注释应该能在不读代码的情况下，能提供足够的信息给调用者调用函数。 文档字符串应该描述函数的调用语法及其语义，而不是其实现。 对于棘手的代码，代码旁边的注释比文档注释更为有效。 def function_with_types_in_docstring(param1, param2): \"\"\"Example function with types documented in the docstring. `PEP 484`_ type annotations are supported. If attribute, parameter, and return types are annotated according to `PEP 484`_, they do not need to be included in the docstring: :param param1: The first parameter. :type param1: int :param param2: The second parameter. :type param2: str :return: The return value. True for success, False otherwise. :rtype: bool \"\"\" ... 关于Type Hints的用法可以参考：typing — Support for type hints、PEP 484。 Classes 在每一个类的定义时都应该添加一个文档注释。 Block and Inline Comments 最后一个需要注释的地方是在代码棘手的地方。如果你将不得不在下一次代码评审时解释它，那么就应该添加注释。 在复杂的功能之前添加注释，非显而易见的行应该在行尾添加注释。 # We use a weighted dictionary search to find out where i is in # the array. We extrapolate position based on the largest num # in the array and the array size and then do binary search to # get the exact number. if i & (i-1) == 0: # true iff i is a power of 2 为了提高可读性，行尾注释应该距离代码至少2个空格。 另外，不要描述代码。 "},"python-style-rules/classes.html":{"url":"python-style-rules/classes.html","title":"Classes","keywords":"","body":"Classes 如果类不需要继承其他基类，那么明确的继承object类，内部类也需要这么做。 class SampleClass(object): pass class OuterClass(object): class InnerClass(object): pass class ChildClass(ParentClass): \"\"\"Explicitly inherits from another class already.\"\"\" "},"python-style-rules/strings.html":{"url":"python-style-rules/strings.html","title":"Strings","keywords":"","body":"Strings 使用format函数或%操作符来进行字符串格式化。当然，如果只是字符串连接，那么使用+号操作符即可。 例如 x = a + b x = '%s, %s!' % (imperative, expletive) x = '{}, {}!'.format(imperative, expletive) x = 'name: %s; score: %d' % (name, n) x = 'name: {}; score: {}'.format(name, n) 错误的写法 x = '%s%s' % (a, b) # use + in this case x = '{}{}'.format(a, b) # use + in this case x = imperative + ', ' + expletive + '!' x = 'name: ' + name + '; score: ' + str(n) 避免在一个循环中使用+或+=操作符来拼接字符串。由于字符串是不可变的，如果那样操作的话将会产生大量的临时对象。 正常情况下，我们可以使用''.join将一个字符串数组拼接起来。 items = [''] for last_name, first_name in employee_list: items.append('%s, %s' % (last_name, first_name)) items.append('') employee_table = ''.join(items) 错误的写法 employee_table = '' for last_name, first_name in employee_list: employee_table += '%s, %s' % (last_name, first_name) employee_table += '' 在写多行字符串时，使用\"\"\"而不是'''。 而不管在什么时候，文档字符串都必须使用\"\"\"。 另外也不要盲目的使用多行字符串，因为它随着代码的缩进可能造成不可预料的错误。 print (\"This is much nicer.\\n\" \"Do it this way.\\n\") 错误的写法 print \"\"\"This is pretty ugly. Don't do this. \"\"\" "},"python-style-rules/files-and-sockets.html":{"url":"python-style-rules/files-and-sockets.html","title":"Files and Sockets","keywords":"","body":"Files and Sockets 在使用完文件或socket之后，必须显式的关闭，除非使用了with语句块。 with open(\"hello.txt\") as hello_file: for line in hello_file: print line 对于不支持with语句的文件类对象，可以使用contextlib.closing()。 import contextlib with contextlib.closing(urllib.urlopen(\"https://www.python.org/\")) as front_page: for line in front_page: print line "},"python-style-rules/todo-comments.html":{"url":"python-style-rules/todo-comments.html","title":"TODO Comments","keywords":"","body":"TODO Comments 对于临时代码，短期解决方案或足够好但不完美的代码使用TODO注释。 在使用TODO注释时，必须同时给出你的名字。 # TODO kl@gmail.com: Use a \"*\" here for string repetition. # TODO Zeke: Change this to use relations. # DONE Stone: fixed something "},"python-style-rules/imports-formatting.html":{"url":"python-style-rules/imports-formatting.html","title":"Imports Formatting","keywords":"","body":"Imports Formatting Imports should be on separate lines. import os import sys 不要 import os, sys Imports应该位于文件的最上方，通常需要进行分组： 基础库 第三方库 应用本身模块 在每一个分组中，根据引用的完整路径进行排序，忽略大小写。 import foo from foo import bar from foo.bar import baz from foo.bar import Quux from Foob import ar "},"python-style-rules/statements.html":{"url":"python-style-rules/statements.html","title":"Statements","keywords":"","body":"Statements 通常一行只有一条语句。 "},"python-style-rules/access-control.html":{"url":"python-style-rules/access-control.html","title":"Access Control","keywords":"","body":"Access Control 如果一个访问器函数不是特别的需要，你可以使用public变量来替代它。 当之后添加更多的功能时，可以使用property来保持语法的一致性。 当然，如果功能更复杂，或访问变量的成本更高，那么应该使用函数调用，类似get_foo()或set_foo()。 若果过去的行为允许直接访问属性，那么不要使用新的访问器函数绑定到这些属性上。 "},"python-style-rules/naming.html":{"url":"python-style-rules/naming.html","title":"Naming","keywords":"","body":"Naming module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_CONSTANT_NAME, global_var_name, instance_var_name, function_parameter_name, local_var_name. 避免使用的名字 除计数器或迭代器外，都不应该使用单个字符作为名字 避免使用中划线作为package/module名字 双下划线开头和结尾的名字 正确的做法如下 Type Public Internal Packages lower_with_under - Modules lower_with_under _lower_with_under Classes CapWords _CapWords Exceptions CapWords - Functions lower_with_under() _lower_with_under() Global/Class Constants CAPS_WITH_UNDER _CAPS_WITH_UNDER Global/Class Variables lower_with_under _lower_with_under Instance Variables lower_with_under _lower_with_under (protected) or __lower_with_under (private) Method Names lower_with_under() _lower_with_under() (protected) or __lower_with_under() (private) Function/Method Parameters lower_with_under - Local Variables lower_with_under - "},"python-style-rules/main.html":{"url":"python-style-rules/main.html","title":"Main","keywords":"","body":"Main 正常情况下，作为脚本的文件也是可以导入的，那么单纯的导入不应该有执行脚本的效果。 主要功能应该都在main()函数中。 def main(): ... if __name__ == '__main__': main() 当作为模块被导入时，所有的代码都会被加载。 注意，不要调用函数、创建对象或其他操作，这些操作在导入时不应该被执行。 "},"django-style-rules/models.html":{"url":"django-style-rules/models.html","title":"Models","keywords":"","body":"Models model名采用大驼峰命名法 字段名全部使用小写字母加下划线格式 必须添加主键，且主键必须是UUIDField字段 值为多选一的字段，必须添加choices参数，且必须使用大写 有需要作为搜索条件的字段都需要加上索引 class Meta必须位于字段定义完成之后，其他函数之前 必须添加这些字段created_time、updated_time、deleted、deleted_time、description model类中的各成员的顺序应遵循以下顺序（不是所有项都是必须的） 所有的数据库字段 自定义的管理器属性（django1.9） class Meta def __unicode__() def __str__() 需要重写的models.Model函数 自定义的property函数 def brief_info() def detail_info() 其他自定义函数 class Person(models.Model): person_id = models.UUIDField(primary_key=True, default=uuid.uuid1, db_index=True) first_name = models.CharField(max_length=20, db_index=True) last_name = models.CharField(max_length=40, db_index=True) GENDERS = ( ('MALE', 'MALE'), ('FEMALE', 'FEMALE'), ) gender = models.CharField(max_length=10, choices=GENDERS, db_index=True) birthday = models.DateTimeField(null=True, db_index=True) job = models.CharField(max_length=200, blank=True, db_index=True) created_time = models.DateTimeField(auto_now_add=True, db_index=True) updated_time = models.DateTimeField(auto_now=True, db_index=True) deleted = models.BooleanField(default=False, db_index=True) deleted_time = models.DateTimeField(null=True) description = models.TextField(blank=True) class Meta: db_table = 'person' def brief_info(self): return { 'person_id': self.person_id.hex, 'first_name': self.first_name, 'last_name': self.last_name, } def detail_info(self): return { 'person_id': self.person_id.hex, 'first_name': self.first_name, 'last_name': self.last_name, 'gender': self.gender, 'birthday': self.birthday.timestamp(), 'job': self.job, 'created_time': self.created_time.timestamp(), 'updated_time': self.updated_time.timestamp(), 'deleted': self.deleted, 'deleted_time': self.deleted_time.timestamp(), 'description': self.description, } "},"django-style-rules/views.html":{"url":"django-style-rules/views.html","title":"Views","keywords":"","body":"Views view名采用大驼峰命名法命名，且必须以View作为后缀 必须继承django.views.generic下的View类或其衍生类：CreateView、DeleteView、UpdateView、DetailView、ListView等 根据http请求的method定义处理函数 处理函数的第二个参数必须是request，不要使用简写或其他名字 登录鉴权操作放在装饰器中，鉴权失败返回状态码403 form表单校验放在装饰器中，校验失败返回状态码422 请求参数校验必须使用Form进行校验，具体参见Forms 除文件或其他二进制数据外，返回的内容都是json格式的数据 class PersonsView(View): @login_required() @form_valid(PersonsGetForm) def get(self, request): data = request.valid_data q = Q() ... persons = Person.objects.filter(q) results = [_.detail_info() for _ in persons] return HttpJsonResponse(results) "},"django-style-rules/forms.html":{"url":"django-style-rules/forms.html","title":"Forms","keywords":"","body":"Forms form名采用大驼峰命名法命名，且必须以Form作为后缀 必须继承django.forms.Form 如果需要预处理单个字段，需要实现clean_[field_name]()函数 如果需要同时预处理多个字段，需要实现clean()函数 值为多选一的字段，必须添加choices参数，且必须使用大写 class PersonCreateForm(forms.Form): first_name = forms.CharField(max_length=20) last_name = forms.CharField(max_length=40) gender = forms.ChoiceField(Person.GENDERS) birthday = forms.FloatField(required=False) job = forms.CharField(max_length=200) description = forms.CharField(required=False) def clean_birthday(self): field = self.cleaned_data['birthday'] if field: return timestamp_to_datetime(field) else: return None "},"django-style-rules/urls.html":{"url":"django-style-rules/urls.html","title":"Urls","keywords":"","body":"Urls 所有url配置都以^开头 父级url都以/结尾 叶子url都以$结尾 使用named groups代替non-named groups，即使用(?Ppattern)代替(pattern) # parent urls urlpatterns = [ url(r'^persons/', include('person.urls')), ] # sub urls urlpatterns = [ url(r'^$', PersonsView.as_view()), url(r'^(?P\\w+)$', PersonView.as_view()), url(r'^(?P\\w+)/job$', PersonJobView.as_view()), ] "}}